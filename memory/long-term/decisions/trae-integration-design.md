# Trae 集成方案设计

## 目标
通过消息形式与 Trae 通信，避免直接 API 调用导致的高 Token 消耗。

## 核心原则
- ❌ 不直接调用 Trae API（消耗 Token）
- ✅ 通过消息/文件间接通信（低成本）
- ✅ 异步处理，非实时但可控
- ✅ 人工可介入，安全可控

---

## 方案对比

### 方案 1: 文件系统消息（推荐）

**通信方式:**
```
龙虾 → 写入消息文件 → Trae 读取 → Trae 处理 → 写入结果文件 → 龙虾读取
```

**实现:**
- 共享目录: `/workspace/projects/workspace/.trae-messages/`
- 龙虾写入: `request-001.json`
- Trae 读取并处理
- Trae 写入: `response-001.json`
- 龙虾读取结果

**优点:**
- ✅ 零 Token 消耗
- ✅ 简单可靠
- ✅ 可审计（所有消息有记录）
- ✅ 人工可随时介入查看

**缺点:**
- ⚠️ 非实时（需要轮询）
- ⚠️ Trae 需要配置自动读取

---

### 方案 2: 本地 Webhook/HTTP

**通信方式:**
```
龙虾 → HTTP POST → 本地轻量服务器 → Trae 监听 → 处理 → HTTP Response
```

**实现:**
- 启动本地 Flask/FastAPI 服务 (端口 8888)
- 龙虾发送 HTTP 请求（无 Token 消耗）
- Trae 通过插件监听本地端口
- 处理后返回结果

**优点:**
- ✅ 相对实时
- ✅ 结构化数据
- ✅ 可扩展性好

**缺点:**
- ⚠️ 需要 Trae 开发/配置插件
- ⚠️ 需要维护本地服务

---

### 方案 3: 剪贴板中转

**通信方式:**
```
龙虾 → 写入剪贴板 → 用户粘贴到 Trae → Trae 处理 → 用户复制结果 → 龙虾读取剪贴板
```

**实现:**
- 龙虾生成指令 → 自动复制到剪贴板
- 用户手动粘贴到 Trae
- Trae 生成代码/结果
- 用户复制结果
- 龙虾读取剪贴板获取结果

**优点:**
- ✅ 完全零成本
- ✅ 无需任何配置
- ✅ 人工全程可控

**缺点:**
- ⚠️ 需要人工介入（粘贴/复制）
- ⚠️ 流程较繁琐

---

### 方案 4: 邮件/消息通知

**通信方式:**
```
龙虾 → 发送邮件 → Trae 集成邮箱 → 处理 → 回复邮件 → 龙虾读取
```

**实现:**
- 龙虾发送邮件到特定地址
- Trae 配置自动处理邮件
- 处理后回复邮件
- 龙虾读取邮件获取结果

**优点:**
- ✅ 异步，可延迟处理
- ✅ 天然有记录
- ✅ 跨平台

**缺点:**
- ⚠️ 延迟较高（分钟级）
- ⚠️ 需要邮件集成

---

## 推荐方案: 文件系统消息 + 剪贴板辅助

### 架构设计

```
┌─────────────┐      ┌──────────────┐      ┌─────────────┐
│   龙虾      │ ──── │  消息文件    │ ──── │    Trae     │
│  (OpenClaw) │      │  (共享目录)   │      │  (IDE/CLI)  │
└─────────────┘      └──────────────┘      └─────────────┘
       │                                          │
       │         方案A: 自动模式                   │
       │         - Trae 配置自动读取脚本            │
       │         - 自动处理并写回结果              │
       │                                          │
       │         方案B: 人工模式                   │
       │         - 用户手动在 Trae 中执行          │
       │         - 复制结果到指定位置              │
       └──────────────────────────────────────────┘
```

### 消息格式

**请求消息 (request-xxx.json):**
```json
{
  "id": "req-20260301-001",
  "timestamp": "2026-03-01T12:30:00Z",
  "source": "openclaw",
  "target": "trae",
  "type": "code_generation",
  "content": {
    "task": "创建一个 Python 函数，用于读取邮件",
    "requirements": ["使用 imaplib", "支持 QQ 邮箱", "处理异常"],
    "context": "当前在开发 email-sender skill"
  },
  "priority": "normal",
  "callback": "file"
}
```

**响应消息 (response-xxx.json):**
```json
{
  "id": "resp-20260301-001",
  "request_id": "req-20260301-001",
  "timestamp": "2026-03-01T12:35:00Z",
  "source": "trae",
  "target": "openclaw",
  "type": "code_generation_result",
  "content": {
    "code": "import imaplib\n...",
    "explanation": "这个函数使用 imaplib 连接到 QQ 邮箱...",
    "files_created": ["read_email.py"]
  },
  "status": "completed",
  "token_used": 0
}
```

---

## 实施步骤

### Phase 1: 基础消息通道（本周）

1. 创建共享消息目录
2. 实现龙虾的消息写入功能
3. 实现龙虾的消息读取功能
4. 测试基础通信

### Phase 2: Trae 集成（下周）

1. 开发 Trae 插件/脚本（自动读取消息）
2. 实现 Trae 的结果写入
3. 测试端到端流程
4. 优化错误处理

### Phase 3: 高级功能（后续）

1. 支持多种消息类型（代码、搜索、分析）
2. 消息队列管理（防止冲突）
3. 状态监控和告警
4. 人工介入界面

---

## 安全考虑

1. **消息验证**: 签名验证防止伪造
2. **权限控制**: 只允许特定目录访问
3. **审计日志**: 所有消息记录可追溯
4. **人工确认**: 重要操作需要人工确认

---

## 成本对比

| 方案 | Token 消耗 | 延迟 | 复杂度 | 推荐度 |
|-----|-----------|------|--------|--------|
| 直接 API 调用 | 高（每次都要） | 实时 | 低 | ❌ |
| 文件消息 | 零 | 秒级 | 中 | ✅ |
| 本地 HTTP | 零 | 实时 | 中 | ✅ |
| 剪贴板 | 零 | 人工 | 低 | ⚠️ |
| 邮件 | 零 | 分钟 | 高 | ⚠️ |

---

**建议先从方案 1（文件消息）开始**，简单可靠，零成本。

老板觉得这个方向可行吗？需要我先实现基础的消息通道吗？
